就是說阿，
一開始起點先往四個方向發散，遇到牆壁之後停下來
start point (x0, y0)
	goNorth (x0, y = y_max(until hit obstacle))
	goSouth (x0, y = y_min(until hit obstacle))
	goWest (x = x_min(until hit obstacle), y0)
	goEast (x = x_max(until hit obstacle), y0)
(然後終點做一樣的事情？
end point (xn, yn)
	goNorth (xn, y = y_max(until hit obstacle))
	goSouth (xn, y = y_min(until hit obstacle))
	goWest (x = x_min(until hit obstacle), yn)
	goEast (x = x_max(until hit obstacle), yn)
)
然後看要不要更新搜尋與終點最近的組合，
也就是說，我們現在有 start' * 4, end' * 4，這樣組合會有16個，
然後挑最近的更新為新的 start point 跟 end point，反覆做。
最後(要try 幾次？)如果沒找到的話，要return沒找到，並往回找。

所以現在我們要研究的是那個 obstacle 的問題。
應該要有一個整個 chip 的牆壁的分布圖，然後判斷
剛剛有問 chatGPT 他好像有給幾個寫法。

Routing 的想法：
好啊 納今天我們假設我們有一個前進方向
然後我們就往這個方向前行，每次走d_distance
並且往這個方向［的兩邊］發出射線，檢查碰到牆壁的位置
一旦發現碰到牆壁的具有增大，代表說這裡可能會是一個出口
所以我們就記錄這個位置，然後持續檢查，直到又有一個變化
那我們就把這之間的點都做一個recurrsion，也就是再 routing 一次
(那終點也要做？)

新的Band search algorithm的發想:
一開始只有起點和終點，以及一堆牆壁
第一個level的band會是只有線，沒有寬度
source(x1, y1)會產生
Band_X(){
	containTerminal = 1;
	zoneName = sourceZoneName;
	direction_isX = 1;
	parent = nullptr;
	minEdge = maxEdge = y1;
	minEnd = maxEnd = x1;
	然後這個band會做direction的detectWall{
		for w : allWalls {
			do {
				maxEnd += dx;
				minEnd += dx;
				if(hitWall) break;
			}
		}
	}
}
Band_Y 做同樣的事情
一樣會有OSB、OTB、CSB、CTB
step1: initialization
step2: search if intersect
step3: store current into old
step4: use current to extend new bands (ESB、ETB)
	   and exchange the extended and current
step5: find the path

請利用c++實作一個程式：
以下是這個程式會用到的一個資料型態：pair
class Pair {
public:
	Pair(){}
	Pair(double Min, double Max) {
		// Min should smaller than Max, 
		// but in case we still check that
		this->min = std::min(Min, Max);
		this->max = std::max(Min, Max);
	}
	double min,max;
	void operator =(Pair const &other) {
		this->min = other.min;
		this->max = other.max;
	}
};
給定一個pair為target，接下來輸入數個pair為sources，
當source的範圍有涵蓋到target，則紀錄這個source，並繼續接收sources，直到整個target的範圍被接收完
如，target為Pair(3.2, 5.7)，sources:
Pair(11.7, 18.0) //這個不會被紀錄因為他不再target的範圍
Pair(0.8, 3.3) // 這個會被紀錄，3.3>=3.2
(因此target目前3.2~3.3這個範圍被涵蓋到了)
Pair(4.6, 4.7) // 這個也在範圍內，會被紀錄
(因此，目前target的[3.2, 3.3], [4.6, 4.7]的範圍被涵蓋到了)
Pair(2.2, 4.62) // 會被紀錄
Pair(4.69, 5.88) // 會被紀錄
此時，target的全部範圍已經被涵蓋，則結束程式。

我想要對這個程式做一些小更動
我想要改成，"只紀錄最先覆蓋的那些sources"，並將這些區間紀錄在 RangeCoverage 裡面
什麼意思呢?舉個例子
Pair target(0, 11);
接下來輸入sources:
Pair(10, 12) // 區間[10, 11]被紀錄在 RangeCoverage 裡面
Pair(0, 7) // 區間[0, 7]被紀錄在 RangeCoverage 裡面
(這裡我們看到，僅剩下[7, 10]這個區間未被紀錄，而接下來就是主要更動的地方)
Pair(0, 9) // 注意到，[0,7]先前已經被紀錄過，所以這邊幫我只紀錄[7,9]就好(在 RangeCoverage 裡面)
Pair(7, 9) // 這個source在target的區間內，但先前[0,9]已經紀錄過，因此[7,9]不應被紀錄
Pair(10,11) // 同理
Pair(2,3) // 同理
Pair(4,13) // 這裡將target補齊了，因為只剩下[9,10]未被紀錄，所以[9,10]被紀錄在 RangeCoverage 裡面
結束程式

讓我們看到這張圖。這張圖代表一個chip上block的分佈
chip的邊界為最外框為紅色的大長方形。
block為chip上一些rectilinear形狀的物體，也就是圖中黃色的部分
block有幾個重要的資訊:
1. vector<Point> vertices: block的頂點
2. string name: BLOCK_0, BLOCK_1等等
3. bool is_feedthroughable: 是否可穿過
4. int through_block_net_num: 可穿過這個block的net數量(但我們今天的重點不在net)
5. vector<Edge> edges: block的邊
edges是我們今天想要討論的
我想要寫一個vector存取chip 上，所有edges的資料(任何一個block)
並且我可以修改這個edges的資訊(include some boolean of that edge)，以方便我接下來程式的進行
(主要是我想要按照他們的fixedCoordinate排序，但這之後再提)
因此，這個vector將會是以指標的形式存在
我想要你幫助我完成這個程式

以下是可能你會需要的資訊：

// 0. Zone.h

class Zone {
public:
  Zone() {}
  string name;
  vector<Point> vertices;
  virtual ~Zone() {}
};

// 1. Block.h

struct BlockEdgeAndNum {
	vector<Point> edge;
	int net_num;
};
class Edge {
public:
	Edge(){}
	Edge(bool, double, Pair, string);
	Edge(bool isVertical, double fixed, double range_min, double range_max, string blockName);

	bool isVertical; // 0: horizontal, 1: vertical
	double fixedCoord;
	Pair rangeCoord;

	void getBlockVertices(Block const &block);
	void rearrangement();
	bool inRange(double const &value) const;

	// 註: 我還沒有完全確定Edge的結構要包含哪些東西
};
class Block : public Zone {
public:
	Block();
	Block(Block const &);
	string blkID;
	Point coordinate;
	string facingFlip;

	int through_block_net_num;
	vector<BlockEdgeAndNum> through_block_edge_net_num;
	vector<vector<Point>> block_port_region;
	bool is_feedthroughable;
	bool is_tile;
	vector<Edge> edges;

	int UNITS_DISTANCE_MICRONS;
	double border_X;
	double border_Y;

	vector<Block> allBlocks;

	void ParserAllBlocks(int const &testCase);
	void expandVertices();
	void showBlockInfo();
};

// 2. Chip.h

class Chip : public Zone {
public:
	Chip(int const &testCase);
	vector<Zone *> totZone;

	double border_X;
	double border_Y;
	
	Edge edges;	
	void showAllZones();
	Block getBlock(string) const;
	Region getRegion(string) const;
	~Chip();
};

如：covered_1 = {
	[0,1],
	[1,5],
	[5,7]
}
covered_2 = {
	[0,1],
	[1,3],
	[3,6]
}
得到最終合併 
vector<Pair> covered_combine(vector<Pair> a, vector<Pair> b) {
	// 程式實作
}
結果 = {
	[0,1],
	[1,3],
	[3,5],
	[5,6],
	[6,7]
}

還記得你之前我向您問過關於rangeCoverage的問題嗎?

我現在想要更改這個程式，變成只輸出splitPoint。 

如果input為 Pair target(0, 11); 
vector sources = {
	Pair(0, 3),
	Pair(2, 5),
	Pair(4, 7),
	Pair(1, 6),
	Pair(6.3, 9),
	Pair(8.6, 11.4)
}; 

則原本的輸出會是 Pair(0, 3) Pair(3, 5) Pair(5, 7) Pair(7, 9) Pair(9, 11)  

我現在只想要輸出 0, 3, 5, 7, 9, 11

我現在想要您幫我寫一個整合的程式
我現在會有兩個vector<CoveredRange>，分別為left和right
我要你幫我做的事是，合併left與right，使得他們生成一組新的vector<Band>

class Band {
public: 
	Pair direction, extended;
};

假設 left: {
	CoveredRange(Pair(1, 6), 1),
	CoveredRange(Pair(7, 9), 2),  
	CoveredRange(Pair(0, 1), 3),       
	CoveredRange(Pair(6, 7), 5),     
	CoveredRange(Pair(9, 11), 6) 
}
right: {
	CoveredRange(Pair(0, 3), 11)
	CoveredRange(Pair(3, 5), 12)       
	CoveredRange(Pair(5, 7), 13)       
	CoveredRange(Pair(7, 9), 15)       
	CoveredRange(Pair(9, 11), 16)
}

left的parameter為band的左邊boundary，同理right也是
一旦left或right的range出現斷層(也就是所謂的splitPoint)
則將此時的左右boundary記起來，儲存在direction，並把此時的range記起來

基本上函式的運作邏輯已經寫在註解裡面了。 
我想問的是，我的設計應該是"如果extendedBand已經存在於oldBands或currentBands或extendedBands"的話，那麼這筆資料就不會被寫入，
所以每當執行到step4時，照理來說應該extendedBand應該都會是新的，沒有出現過的Band
但當我執行
cout << "> CSB:\n";
printBands(CSB);
cout << "> CTB:\n";
printBands(CTB);
的時候，會發現舊的Band仍然存在於currentBand(currentBand是由extendedBand寫入)
我懷疑有兩種因素造成:
1. 是指標操作上有錯誤才導致
2. alreadyExist的函式判斷邏輯有誤
所以我這裡提供 alreadyExist的函式代碼

bool Band::operator ==(Band* const other) const {
	return this->x == other->x && this->y == other->y;
}
bool Band::alreadyExist(vector<Band*> bands) {
	for (Band* const b : bands) {
		if (this == b) {
        	cout << "x: [" << b->x.min << ", " << b->x.max << "]";
        	cout << " y: [" << b->y.min << ", " << b->y.max << "]" << endl;
			return 1;
		}
	}
	return 0;
}

同時，也有可能是判斷式中，指標的錯誤比對造成
想請問我哪裡有寫錯，請不吝嗇告訴我

// chatGPT認為是我的比較內容有誤

但首先，alreadyExist我就是故意要設計成說，如果他們的x跟y相等的話就return true
況且新生成的Band的指標位址一定跟原本存在的指標位址不同
我的"指標操作上有錯誤"是指說我可能沒有正確的刪除、複製、或指向要操作的資料
希望你可以針對這個下去解答。
若您真的很需要mergeCoveredRanges 相關的代碼的話，我在這邊貼給您參考，
但我已經demo過，應該不太可能會有問題(但很有可能問題就在這裡)

我有一個重大的發現
我在不更動程式碼的情況下，連續執行兩次
我發現，輸出的結果不一樣，這讓我更確信一定是指標記憶體的 操作不當
請不要吝嗇，並詳細的在看一次程式碼，檢查哪裡可能會造成指標的操作有誤
如指標的vector操作(push_back、clear等等)，或是沒有適當delete，或是兩vector之間元素的轉移等等

現在遇到的問題
1. edge要連結到block，所以我現在在寫Edge裡面有 Block *block 這個東西 // 待確認
2. 從chip.totEdge蒐集到的edges似乎不正確，可能很需要重新檢查一下
3. 我現在在想那些facingflip再平移的那個地方到底有沒有問題
4. net 的 must_through 的座標我記得好像還沒處理facingflip
5. band search 應該是要等source bands 完全 intersect 到 level 0 的 target 才可以結束
	在這之前所有得到的intersect的band path的可能都要記錄下來
	band path要寫一個函式，得到確切每一條band path中的最短路徑
	然後在這些path裡面找到最短的那一條當作最終結果
6. 還沒處理must through 的部分
7. 還沒處理feedthrough 一個block的時候要 through_net_num--
8. 應該先這樣有想到再說

我有一些指標無法正確存取的問題
以下是我程式的架構，共有Employee、Office、Company與main這些

** Employee.h
#ifndef EMPLOYEE_H
#define EMPLOYEE_H

#include <string>

class Office; // 前向声明

class Employee {
public:
    Employee(std::string n, int i);
    std::string name;
    int ID;
    Office* office; // 指向所属 Office 的指针
};

#endif // EMPLOYEE_H

** Employee.cpp
#include "Employee.h"

Employee::Employee(std::string n, int i) : name(n), ID(i), office(nullptr) {}

** Office.h
#ifndef OFFICE_H
#define OFFICE_H

#include <vector>
#include <string>
#include "Employee.h"

class Office {
public:
    Office(std::string addr);
    std::string address;
    std::vector<Employee> employees;

    Employee addedEmployee(std::string n, int i);
};

#endif // OFFICE_H

** Office.cpp
#include "Office.h"

Office::Office(std::string addr) : address(addr) {}

Employee Office::addedEmployee(std::string n, int i) {
    Employee newEmployee(n, i);
    newEmployee.office = this; // 设置 office 指针
    employees.push_back(newEmployee);
    return newEmployee;
}

** Company.h
#ifndef COMPANY_H
#define COMPANY_H

#include <vector>
#include "Office.h"

class Company {
public:
    void setAllOffices();
    void addOffice(Office& office);

    std::vector<Office> allOffices;
    std::vector<Employee> allEmployees;
};

#endif // COMPANY_H

** Company.cpp
#include "Company.h"
#include <string>

void Company::setAllOffices() {
    for (int i = 0; i < 3; i++) {
        std::string office_addr(1, 'G' + i);
        Office tempOffice(office_addr);
        for (int j = 0; j < 3; j++) {
            std::string employee_name = office_addr + "_emp_" + std::to_string(j);
            Employee newEmployee = tempOffice.addedEmployee(employee_name, j);
            allEmployees.push_back(newEmployee); // 添加到 allEmployees
        }
        addOffice(tempOffice);
    }
}

void Company::addOffice(Office& office) {
    allOffices.push_back(office);
}

** main.cpp
#include <iostream>
#include "Company.h"

int main() {
    Company company;
    company.setAllOffices();

    for (const Employee& emp : company.allEmployees) {
        std::cout << "Employee: " << emp.name << ", Office Address: " << emp.office->address << std::endl;
    }

    return 0;
}

在執行到main中的印出emp.office->address時，會無法印出東西，或直接結束程式，請問要如何修改？

d(ln(dmu)) < 10/ln(ln(mu)) && d(dpsi) < sqrt(costUpS(1))
psi + dpsi > (costUpS(1) + costUpS(2))

我會給定一個 vector<Point> area = {
	Point(x0, y0),
	Point(x1, y1),
	Point(x2, y2),
	Point(x3, y3),
	...
}

注意！此area必定為rectilinear圖形

然後會有一個點Point(x, y)，寫一個程式 bool isInside(/*variables*/);
判斷這個點是否會在這個area裡面

example:

vector<Point> area = {
	Point(0, 0),
	Point(10, 0),
	Point(10, 10),
	Point(8, 10),
	Point(8, 2),
	Point(2, 2),
	Point(2, 8),
	Point(6, 8),
	Point(6, 10),
	Point(0, 10)
}

Point p1(3, 3); // isInside = false;
Point p2(9, 5); // isInside = true;

寫一個用python matplotlib 繪製多個長方形的程式
csv的格式會是：
group,x1,y1,x2,y2
x1,y1,x2,y2會組成一個長方形，group則會決定哪些長方形是一組的
同一組的長方形會share同樣的顏色。

那些很奇怪的位置的channel，反正之後會有intersect，如果intersect的數量為0，那就把這個channel給殺了

我想問關於path finding node 細化的問題
假設我現在有一個單位為2的node diagram{
	(0,0),(2,0),(4,0),(6,0)...
	(0,2),(2,2),(4,2),(6,2)...
	(0,4),(2,4),(4,4),(6,4)...
	...
}
然後我最終的path也"一定"會在這些nodes上
如：有一條path A{(0,0),(12,0),(12,6),(10,6)}
那假設我現在多了 數個隨機的，單位為1的nodes
如上述所述，這些單位為1nodes並不會是path的node
但有可能會位在最終找到的path的路徑上
比如剛剛提到的path A，在(0,0)->(12,0)的路徑上可能有一個點(7,0)
(但是在紀錄這條path的時候仍然只紀錄有轉折的點，因此(7,0)不會被紀錄)
那我現在的問題是，我在做search algorithm的時候，會不會受到這些nodes的影響
比如說 Dijkstra’s algorithm 或 A* algorithm 好了，會不會改變運算時間

我想重新闡述我的問題：
1. 我的問題應該不是想問曼哈頓距離的A*演算法的實現，
而是想問說，是在一個二維平面上進行A*演算法，"如果"只以距離作為考量，則他的cost要如何計算
2. 請改寫成 c++的程式。

有兩個關於迴圈的問題想要請教
我先問第一個:
vector<MyClass> vec;
for (auto const &m: vec){
	// other operation
	for (auto const &n: vec){
		n.MyFunction(n);
		// other operation
	}
}
我是想問說這個有沒有更聰明的解法?就是同一個vector的雙重運算

vector<MyClass> vec;
for (/*拜訪vec中的元素 m*/){
	for (/*拜訪vec中的元素 n*/){
		m.MyFunction(n);
		// 如果今天我的 MyFunction是會造成vec中元素的消失(刪除元素)，
		// 請問這樣會對迴圈造成什麼樣的影響?
	}
}
[10401.000,10440.000/4909.999],
[10401.000,10440.000/4909.999]

class Node {
public:
    int x, y;
    double weight = 0;
    Node (int X, int Y): x(X), y(Y) {}
    Node (int X, int Y, double w): x(X), y(Y), weight(w) {}

	vector<Node*> neighbors; // or std::set<Node>
	// 可能會使用 shared_ptr<Node>
};

class NodeManagerPrecomputed {
private:
    std::map<int, std::map<int, Node>> nodes;

public:
    void addNode(int x, int y, double weight = 0) {
        nodes[x][y] = node(x, y, weight);
        updateNeighbors(x, y);
    }

    void recordNeighbors(int x, int y) {
        // TODO
    }

    std::vector<Node*> getNeighbors(int x, int y) {
        return nodes[x][y].neighbors;
    }
};

int main() {
    std::set<int> x_value = { 1, 3, 7, 8, 10, 16, 24, 45 };
    std::set<int> y_value = { 3, 4, 8, 9, 15, 21, 23 };

    Node_manager Nodes;

    for (int const &x: x_value) {
        for (int const &y: y_value) {
            Nodes.addNode(Node(x, y));
        }
    }

    cout << "\ndone.";
    return 0;
}
請完成recordNeighbors

以下詳細定義neighbor：如code 所顯示:
std::set x_value = { 1, 3, 7, 8, 10, 16, 24, 45 };
std::set y_value = { 3, 4, 8, 9, 15, 21, 23 };
代表所產生出來的node 的座標會有哪些組合
如x=1的node會有(1,3), (1,4), (1,8), (1,9), (1,15), (1,21), (1,23)
以此類推，而neighbor的定義為相同x或相同y下，他的前一個、下一個node即為neighbor
且斜對角不算是neighbor
如：以node(1,9)來說，他的neighbor會有node(1,8)(y方向前一個)、node(1,15)(y方向下一個)、node(3,9)(x方向下一個)，共三個

我有以下兩個問題
A* 的g_value 是會繼承的嗎
我對於A*的理解是，在Open中找出f_value 最小的node(nowNode)，
計算完他所有鄰居的f_value，將鄰居放到Open，自己放到 Close。
我想問的是，請問有沒有可能在nowNode找到一個他的鄰居，
這個鄰居n 在Close裡面，且他的f_value比這個已經在close裡面的node還要來的小?

我想做關於A* algorithm 的變形
當一條路徑的轉彎越少，則這條線的cost 越少，也就是越 optimize
如：我們今天有一條路徑要從(1,1)到(3,3)
則我們考慮三種路徑：
A:{(1,1), (2,1), (2,2), (3,2), (3,3)}
B:{(1,1), (2,1), (2,3), (3,3)}
C:{(1,1), (3,1), (3,3)}
則cost的排序會是 C<B<A，其中A轉彎3次、B轉彎2次，C轉彎1次
請問要如何實現，且符合heuristic?

以下是我目前寫的 a* algorithm 的 code，其中 TURN_COST我設為10000，是因為straight的數字都很大(>1e5)
其中裡面有很多debug_log的code以方便我觀察
我發現有問題的地方在於，有一些node已經存在於close，然而有一些neighbor所計算出來的 f_value反而會比已存在的還要小，which is 不合理，
所以我在想是不是有哪裡違反了 heuristic，請直接告訴我可能有問題的地方。
另外我發現您提供的code中，只有一個open而沒有close，且指專注於open中最小f的node去產生他的neighbor，
請問這樣做的目的是讓所有的node都可以被重新計算f_value，從而更新數值去找到最佳路徑嗎?

確定為下
./test0818 50 path/case00 case00_cfg.json case0.json
cd "c:\Users\照元喔\source\repos\Problem_D_Edge_mut2\" ; if ($?) { g++ -std=c++20 test0818.cpp -o test0818 } ; if ($?) { ./test0818 50(tracks/um) path/case00 case00_cfg.json case0.json }

Problem nets:
49
152
179
257-1, 257 -2
264-1
265
308-1
310-5
311-4

我想要你幫我寫一個合理的判斷式，來判斷我在做node search的時候，從現在這個node(nowNode)到下一個node(nextNode)能否走
規則如下：
node的屬性有:(Block*)block; block有屬性(bool)is_feedthroughable
我們有一個sourceNode與一個target Node
1. 如果nowNode->block == sourceNode->block，則任何nextNode都可以走
2. 如果nextNode->block->is_feedthroughable == 1 或 == nullptr，則這個nextNode可以走
	else 不能走
3. 如果nextNode->block == targetNode->block，則這個nextNode可以走

forbid_1:
6, 20, 82, 83, 84, 85, 86, 87, 130, 133, 134, 145, 146, 149, 150, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 165, 167, 168, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 190, 191, 192, 201, 214, 215, 216, 217, 259, 261, 266, 269, 271, 272, 277, 278, 281, 282, 283, 284, 285, 302, 315, 316, 319, 320, 383, 384, 513, 514, 584, 585, 586, 593, 594, 595, 596, 597, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 620, 623, 624, 625, 627, 628, 629, 630, 631, 632, 633, 642, 643, 648, 649, 656, 657, 660, 661, 662, 663, 664, 665, 667, 668, 669, 672, 673, 674, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 688, 689, 691, 692, 693, 694, 695, 696, 697, 698, 699, 703, 705, 706, 710, 711, 715, 720, 721, 722, 723, 724, 725, 726, 727, 728, 731, 732, 733, 734, 735, 736, 737, 738, 739, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 765, 766, 767, 768, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 790, 792, 793, 794, 795, 796, 797, 800, 802, 811, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 834, 835, 836, 837, 838, 839, 840, 841, 842, 844, 848, 849, 850, 851, 852, 853, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 906, 907, 908, 909, 910, 911, 949, 958, 959, 960, 961, 967, 968, 969, 970, 976, 977, 978, 979, 980, 981, 982, 1004, 1005, 1007, 1008, 1009, 1010, 1011, 1013, 1014, 1015, 1019, 1020, 1021, 1022, 1023, 1024, 1026, 1029, 1030, 1031, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1042, 1043, 1044, 1045, 1046, 1047, 1050, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1071, 1072, 1073, 1074, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1092, 1093, 1094, 1096, 1097, 1098, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1109, 1113, 1114, 1115, 1116, 1117, 1118, 1120, 1121, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1136, 1137, 1141, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1160, 1161, 1162, 1163, 1164, 1168, 1170, 1173, 1175, 1176, 1177, 1181, 1183, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1197, 1198, 1199, 1200, 1201, 1202, 1204, 1206, 1208, 1212, 1213, 1214, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1229, 1230, 1231, 1232, 1233, 1234, 1236, 1237, 1238, 1241, 1242, 1247, 1248, 1249, 1250, 1251, 1252, 1254, 1256, 1259, 1260, 1262, 1264, 1267, 1269, 1272, 1279, 1280, 1281, 1282, 1285, 1286, 1287, 1288, 1289, 1291, 1298, 1299, 1300, 1302, 1303, 1305, 1306, 1308, 1310, 1311, 1312, 1313, 1314, 1315, 1317, 1318, 1319, 1321, 1323, 1326, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1346, 1347, 1349, 1350, 1351, 1352, 1353, 1354, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1377, 1378, 1380, 1382, 1390, 1391, 1392, 1393, 1394, 1406, 1407, 1408, 1409, 1410, 1412, 1415, 1416, 1417, 1418, 1419, 1422, 1423, 1424, 1425, 1426, 1427, 1429, 1430, 1431, 1433, 1435, 1436, 1438, 1439, 1440, 1442, 1443, 1444, 1447, 1448, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1709, 1710, 1713, 1714, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1754, 1755, 1756, 1759, 1762, 1763, 1765, 1766, 1768, 1771, 1773, 1774, 1775, 1776, 1777, 1778, 1780, 1782, 1783, 1787, 1788, 1790, 1796, 1806, 1810, 1811, 1812, 1814, 1815, 1818, 1819, 1821, 1822, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1855, 1858, 1859, 1860, 1863, 1864, 1869, 1870, 1872, 1873, 1875, 1876, 1877, 1878, 1879, 1887, 1888, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1898, 1899, 1900, 1910, 1911, 1913, 1915, 1917, 1918, 1919, 1920, 1921, 1922, 1924, 1925, 1926, 1929, 1933, 1934, 1935, 1936, 1937, 1940, 1943, 1947, 1951, 1952, 1953, 1954, 1955, 1956, 1958, 1959, 1962, 1964, 2000, 2001, 2018, 2019, 2020, 2021, 2022, 2029, 2141, 2148, 2149, 2150, 2172, 2173, 2174, 2190, 2191, 2215, 2216, 2217, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2251, 2253, 2254, 2255, 2262, 2263, 2293, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466

class Cell : public std::enable_shared_from_this<Cell> {
public:
	Cell(){}
};

class Node : public Cell {
public:
	Node(shared_ptr<Cell> Grid, int Turn): cell(Grid), turn(Turn) {}
	Node(shared_ptr<Cell> Grid): cell(Grid) {}
	shared_ptr<Node> generateNeighbor(const shared_ptr<Cell>&, std::ofstream&);
};

shared_ptr<Node> Node::generateNeighbor(const shared_ptr<Cell> &n, std::ofstream &file) {
	shared_ptr<Node> neighbor = make_shared<Node>(n);
	neighbor->parent = shared_from_this(); //error here

	return std::move(neighbor);
}

我有一個bug檢查不出來

void Cell_Manager::createCells(
	const vector<shared_ptr<Block>> &allBlocks,
	const vector<Edge> &allBPRs,
	const vector<shared_ptr<EdgeNetNum>> &allTBENNs,
	const Net net
) {
	int x_count = 0;
	for (auto x1 = x_value.begin(); x1 != x_value.end(); ++x1) {
        auto x2 = std::next(x1);
        if (x2 == x_value.end()) break;
		int y_count = -1;

		for (auto y1 = y_value.begin(); y1 != y_value.end(); ++y1) {
			auto y2 = std::next(y1);
			if (y2 == y_value.end()) break;

			Cell tempCell(Pair(*x1, *x2), Pair(*y1, *y2));
			tempCell.checkInsideBlock(allBlocks);

			for (auto const &e: allBPRs) {
				if (tempCell.EdgeBelongs2Cell(e)) tempCell.BPR = e;
			}
			for (auto const &enn: allTBENNs) {
				const Edge e = enn->edge;
				if (tempCell.EdgeBelongs2Cell(e)) tempCell.TBENN = enn;
			}
			for (auto const &e: net.allOrderedMTs) {
				if (tempCell.EdgeBelongs2Cell(e)) {
					tempCell.someNetsMT = e;
					if (tempCell.someNetsMT.block->name == "BLOCK_11") cout << tempCell.someNetsMT.netID << "\n"; // 這裡
				}
			}
			if (tempCell.someNetsMT.block) {
				if (tempCell.someNetsMT.block->name == "BLOCK_11") cout << " : " << tempCell.someNetsMT.netID << "\n"; // 這裡
			}
			tempCell.xIndex = x_count;
			tempCell.yIndex = ++y_count;
			cells[x_count][y_count] = std::make_shared<Cell>(tempCell);
		}
		++x_count;
    }
	cout << "finished create\n";
	for (const auto &out: cells) {
		for (const auto &inner: out.second) {
			const auto c = inner.second;
			if (c->inBlock() == false) continue;
			if (c->block->name == "BLOCK_11") {
				if (c->isSomeNetsMT()) cout << c->someNetsMT.netID << "\n";
			}
		}
	}
}

輸出:
182
1016
2311
 : 2311
2311
 : 2311
finished create
2311
2311

我不懂為什麼離開揮圈之後有部分的屬性就丟失了，這讓我很困擾

class Cell : public std::enable_shared_from_this<Cell> {
public:
	Cell(){}
	Cell(Pair, Pair);

    Pair x, y;
	int xIndex, yIndex;
	shared_ptr<Block> block = nullptr;

	Point node;
	bool inBlock();
	bool inNonfeed();
	bool valid() { return 1; /*TODO*/ }
	Edge BPR = Edge();
	shared_ptr<EdgeNetNum> TBENN;
	Edge someNetsMT = Edge();
	bool isBPR() { return BPR.first.x != -99; }
	bool isSomeNetsMT() { return (bool)someNetsMT.block; }

    bool enclose(const Point&);
	void checkInsideBlock(vector<shared_ptr<Block>>);
	bool EdgeBelongs2Cell(const Edge &e);
	bool canGo(const shared_ptr<Cell>&);
	bool capacityEnough(int);

    bool operator <=(const Cell &other) const;
	bool operator <(const Cell &other) const;
    friend std::ostream& operator<<(std::ostream& os, const Cell& b);
};

class Cell_Manager {
private:
	set<int> x_value, y_value;
public:
	Cell_Manager() {}
	map<int, map<int, shared_ptr<Cell>>> cells;
	void setXYvalue(set<int>, set<int>);
	void createCells(const vector<shared_ptr<Block>>&, const vector<Edge>&, const vector<shared_ptr<EdgeNetNum>>&, int, Point);
	void createCells(const vector<shared_ptr<Block>>&, const vector<Edge>&, const vector<shared_ptr<EdgeNetNum>>&, const Net);
	shared_ptr<Cell> cellEnclose(const Point&);
	set<shared_ptr<Cell>> cellsOnVertex(const Point&);
	set<shared_ptr<Cell>> getNeighbor(const shared_ptr<Cell>&);
};